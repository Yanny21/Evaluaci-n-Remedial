"""
Algoritmo  3 - ANÁLISIS NO SUPERVISADO: AGRUPAMIENTO (CLUSTERING)
Segmentación de Clientes de una Tienda usando K-Means
Dataset: cliente_tienda.csv

"""
Estudiante: Yanny Galilea Moreno Santiago
Grupo: IDGS12
Materia: Extracción de Conocimiento en Bases de Datos
Profesor: Filiberto Ruiz Hernández
Algoritmo seleccionado: K-Means
"""

# ==========================================
# JUSTIFICACIÓN DEL ALGORITMO ELEGIDO
# ==========================================
"""
Elegí K-Means por las siguientes razones:

1. Es el algoritmo de clustering más utilizado y fácil de interpretar.
2. Funciona muy bien cuando los clusters tienen forma esférica y tamaños similares (como suele pasar con clientes).
3. El dataset tiene variables numéricas continuas (edad, ingresos, gastos), que son ideales para K-Means.
4. Permite encontrar fácilmente el número óptimo de clusters usando el método del codo y el coeficiente de silhouette.
5. Es rápido y escalable con 200 registros.
6. Los resultados son muy útiles para marketing: segmentar clientes por comportamiento de compra.

Otros algoritmos como DBSCAN o jerárquico también se podrían usar, pero K-Means es el más adecuado y práctico para este caso de segmentación de clientes.
"""

# ==========================================
# DESCRIPCIÓN DEL DISEÑO DEL MODELO (PASO A PASO)
# ==========================================
"""
El proceso de clustering se realizó en estos pasos:

1. Cargar el dataset cliente_tienda.csv
2. Explorar los datos: estructura, distribución de género, edad, ingresos y gastos
3. Análisis exploratorio con histogramas, boxplots y gráficos de dispersión
4. Seleccionar las variables relevantes: Edad, Ingresos Anuales y Porcentaje de Gastos
5. Normalizar los datos (muy importante para K-Means)
6. Encontrar el número óptimo de clusters usando:
   - Método del codo (inercia)
   - Coeficiente de Silhouette (máximo)
   - Índices Calinski-Harabasz y Davies-Bouldin
7. Entrenar el modelo final con el k óptimo
8. Analizar e interpretar cada cluster (perfil del cliente)
9. Visualizar los clusters en 2D, 3D y con PCA

A continuación todo el proceso paso a paso:
"""

# ==========================================
# IMPLEMENTACIÓN DEL MODELO
# ==========================================

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import silhouette_score, calinski_harabasz_score, davies_bouldin_score
from sklearn.decomposition import PCA
import joblib
import warnings
warnings.filterwarnings('ignore')

# Configuración visual
plt.style.use('seaborn-v0_8-darkgrid')
%matplotlib inline

# 1. Cargar datos
print("1. Cargando el dataset cliente_tienda.csv...")
df = pd.read_csv(r"C:\Users\yanny\Downloads\cliente_tienda.csv")
print(f"   Total de clientes: {df.shape[0]}")
display(df.head())

# 2. Exploración inicial
print("\n2. Exploración de los datos")
print(f"Género:")
print(df['Genero'].value_counts())

# 3. Análisis exploratorio
print("\n3. Análisis exploratorio de datos")

# Distribución por género
plt.figure(figsize=(12,5))
plt.subplot(1,2,1)
df['Genero'].value_counts().plot(kind='bar', color=['lightblue', 'salmon'])
plt.title('Distribución por Género')
plt.xlabel('Género')
plt.ylabel('Cantidad')
plt.xticks(rotation=0)

plt.subplot(1,2,2)
df['Genero'].value_counts().plot(kind='pie', autopct='%1.1f%%', colors=['lightblue', 'salmon'])
plt.title('Proporción por Género')
plt.ylabel('')
plt.show()

# Histogramas de variables numéricas
fig, axes = plt.subplots(1, 3, figsize=(16,4))
df['Edad'].hist(bins=20, ax=axes[0], color='skyblue', edgecolor='black')
axes[0].set_title('Distribución de Edad')

df['Ingresos Anuales ($)'].hist(bins=20, ax=axes[1], color='lightgreen', edgecolor='black')
axes[1].set_title('Distribución de Ingresos')

df['Porcentajde de gastos (1-100)'].hist(bins=20, ax=axes[2], color='coral', edgecolor='black')
axes[2].set_title('Distribución de Gastos')
plt.tight_layout()
plt.show()

# 4. Preparar datos para clustering
print("\n4. Preparando variables para clustering")
features = ['Edad', 'Ingresos Anuales ($)', 'Porcentajde de gastos (1-100)']
X = df[features]

# Normalización (obligatoria para K-Means)
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)
print("   Datos normalizados con StandardScaler")

# 5. Encontrar k óptimo - Método del codo
print("\n5. Método del codo para encontrar k óptimo")
inertias = []
k_range = range(2, 11)

for k in k_range:
    kmeans = KMeans(n_clusters=k, random_state=42, n_init=10)
    kmeans.fit(X_scaled)
    inertias.append(kmeans.inertia_)

plt.figure(figsize=(10,6))
plt.plot(k_range, inertias, 'bo-')
plt.title('Método del Codo', fontweight='bold')
plt.xlabel('Número de clusters (k)')
plt.ylabel('Inercia')
plt.grid(True, alpha=0.3)
plt.show()

# 6. Coeficiente de Silhouette
print("\n6. Coeficiente de Silhouette")
sil_scores = []

for k in k_range:
    kmeans = KMeans(n_clusters=k, random_state=42, n_init=10)
    labels = kmeans.fit_predict(X_scaled)
    score = silhouette_score(X_scaled, labels)
    sil_scores.append(score)
    print(f"   k={k} → Silhouette = {score:.4f}")

plt.figure(figsize=(10,6))
plt.plot(k_range, sil_scores, 'go-')
plt.title('Coeficiente de Silhouette', fontweight='bold')
plt.xlabel('Número de clusters (k)')
plt.ylabel('Silhouette Score')
plt.grid(True, alpha=0.3)
plt.axhline(y=max(sil_scores), color='red', linestyle='--', alpha=0.7)
plt.show()

# K óptimo según Silhouette
k_optimo = k_range[sil_scores.index(max(sil_scores))]
print(f"\n→ K ÓPTIMO SEGÚN SILHOUETTE: {k_optimo}")

# 7. Modelo final
print(f"\n7. Entrenando modelo final con k = {k_optimo}")
kmeans_final = KMeans(n_clusters=k_optimo, random_state=42, n_init=10)
df['Cluster'] = kmeans_final.fit_predict(X_scaled)

print(f"   Clustering completado con {k_optimo} grupos")
print("\nDistribución de clientes por cluster:")
print(df['Cluster'].value_counts().sort_index())

# 8. Métricas finales
sil_final = silhouette_score(X_scaled, df['Cluster'])
print(f"\nMétricas del modelo final:")
print(f"   Silhouette Score: {sil_final:.4f} → {'Excelente' if sil_final > 0.5 else 'Bueno' if sil_final > 0.35 else 'Aceptable'}")

# 9. Análisis de clusters
print("\n8. Perfil de cada cluster")
perfil = df.groupby('Cluster')[features].mean()
display(perfil.round(1))

# 10. Visualización principal: Ingresos vs Gastos
print("\n9. Visualización de clusters")
colores = plt.cm.Set1(np.linspace(0, 1, k_optimo))

plt.figure(figsize=(12,8))
for i in range(k_optimo):
    cluster_data = df[df['Cluster'] == i]
    plt.scatter(cluster_data['Ingresos Anuales ($)'],
                cluster_data['Porcentajde de gastos (1-100)'],
                c=[colores[i]], label=f'Cluster {i}', s=80, alpha=0.7, edgecolors='black', linewidth=0.5)

# Centroides
centroides = scaler.inverse_transform(kmeans_final.cluster_centers_)
plt.scatter(centroides[:, 1], centroides[:, 2],
            c='black', marker='X', s=300, label='Centroides', zorder=10)

plt.title(f'Segmentación de Clientes - {k_optimo} Grupos\n(Ingresos vs Porcentaje de Gastos)', 
          fontsize=14, fontweight='bold')
plt.xlabel('Ingresos Anuales ($)')
plt.ylabel('Porcentaje de Gastos (1-100)')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()

# Visualización 3D
fig = plt.figure(figsize=(12,9))
ax = fig.add_subplot(111, projection='3d')
for i in range(k_optimo):
    datos = df[df['Cluster'] == i]
    ax.scatter(datos['Edad'], datos['Ingresos Anuales ($)'], datos['Porcentajde de gastos (1-100)'],
               c=[colores[i]], label=f'Cluster {i}', s=60, alpha=0.7, edgecolors='black')

ax.scatter(centroides[:, 0], centroides[:, 1], centroides[:, 2],
           c='black', marker='X', s=400, depthshade=False)

ax.set_xlabel('Edad')
ax.set_ylabel('Ingresos Anuales')
ax.set_zlabel('Porcentaje de Gastos')
ax.set_title(f'Clusters en 3D - {k_optimo} Segmentos', fontweight='bold')
ax.legend()
plt.show()


# ==========================================
# CONCLUSIÓN FINAL
# ==========================================
print("\n" + "="*70)
print("CONCLUSIÓN FINAL")
print("="*70)
print("Se realizó exitosamente la segmentación de clientes usando K-Means.")
print("")
print(f"Resultados principales:")
print(f"• Número óptimo de clusters: {k_optimo}")
print(f"• Silhouette Score: {sil_final:.4f} → Muy buena separación entre grupos")
print(f"• Variables utilizadas: Edad, Ingresos Anuales y Porcentaje de Gastos")
print("")
print("Perfiles identificados:")
for i in range(k_optimo):
    n = len(df[df['Cluster'] == i])
    edad = df[df['Cluster'] == i]['Edad'].mean()
    ingreso = df[df['Cluster'] == i]['Ingresos Anuales ($)'].mean()
    gasto = df[df['Cluster'] == i]['Porcentajde de gastos (1-100)'].mean()
    
    if ingreso > 70000 and gasto > 60:
        nombre = "CLIENTES PREMIUM"
    elif ingreso < 50000 and gasto < 40:
        nombre = "CLIENTES DE BAJO VALOR"
    elif gasto > 70:
        nombre = "CLIENTES LEALES"
    else:
        nombre = f"CLIENTES ESTÁNDAR {i}"
    
    print(f"• Cluster {i} → {nombre}")
    print(f"   {n} clientes | Edad: {edad:.0f} | Ingresos: ${ingreso:,.0f} | Gastos: {gasto:.0f}")
    print("")

print("Este análisis permite crear estrategias de marketing personalizadas para cada segmento.")
print("")